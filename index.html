<!DOCTYPE html>
<html>
<head>
	<title>Snake</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="icon" type="image" href="http://assets.stickpng.com/images/58428b65a6515b1e0ad75aaf.png">

	<meta name="viewport" content="width=device-width, initial-scale=1.0">

	<link rel="preconnect" href="https://fonts.gstatic.com">
	<link href="https://fonts.googleapis.com/css2?family=Coda&display=swap" rel="stylesheet">
	<link rel="preconnect" href="https://fonts.gstatic.com">
	<link href="https://fonts.googleapis.com/css2?family=Inconsolata:wght@200&display=swap" rel="stylesheet">

	<style type="text/css">
		body
		{
			background-color: rgba(57, 86, 104 , 0.7);
			background-image: url("https://i.pinimg.com/originals/68/b3/52/68b35214959edb3e39bc8a1fb80c54bd.png");
			background-blend-mode: multiply;
			background-repeat: no-repeat;
			background-attachment: fixed;
			background-position: center;
			background-size: cover;
			position: relative;
			overscroll-behavior: contain;
		}
		div
		{
			margin: 0;
			padding: 0;
			box-sizing: border-box;
		}
		h1, h2, h3, h4, h5, h6, ul{
			margin: 0;
			padding: 0;
		}
		button:disabled, button[disabled]{
			filter: brightness(50%) contrast(70%) saturate(70%) invert(10%);
			cursor: default;
		}

		#sideButton{
			position: fixed;
			top: 20vh;
			left: 0;

		}
		#sideButton-menu{
			width: 200px;
		}

		#menu-button:hover{
			filter: brightness(120%);
			transition: .3s;
		}
		
		#difficulty-slider:hover{
			background-color: rgba(212, 218, 234,1);
		}
		#difficulty-slider::-webkit-slider-thumb{
			appearance: none;
			width: 15px;
			height: 15px;
			cursor: pointer;
			border-radius: 5px;
			background-color: rgba(70, 94, 157, 1);
		}
		#difficulty-slider{
			appearance: none;
			background-color: rgba(179, 183, 193 , 1);
			border-radius: 5px;
			overflow: hidden;
		}

		#game-container{
			display: flex;
			flex-direction: column;
			flex-wrap: nowrap;
		}
		
		#game-control{
			padding: 10px;
			display: flex;
			flex-direction: column;
			flex-wrap: nowrap;
			justify-content: space-around;
			align-items: flex-stretch;
		}
		#game-button-start{
			margin-bottom: 5px;

			height: 2rem;
			width: 5rem;
			border: none;
			outline: none;
			font-size: 1rem;
		}
		#game-button-pause{
			height: 2rem;
			width: 5rem;
			border: none;
			font-size: 1rem;
		}
		#game-score-board{
			display: flex;
			flex-direction: column;
			flex-wrap: nowrap;
			font-size: 1.2rem;
		}
		#game-score-time, #game-score-score, #game-score-highscore{
			margin: 0;
			width: 100px;
			font-size: 1.2rem;
		}

		@media (orientation: landscape) {
			#game-container{
				flex-direction: row;
			}
			#game-control{
				flex-direction: column;
			}
			#game-score-board{
				flex-direction: column;
			}
		}

		@media (orientation: portrait) {
			#game-container{
				flex-direction: column;
			}
			#game-control{
				flex-direction: row;
			}
			#game-score-board{
				flex-direction: row;
				align-items: center;
			}
		}

		#game-screen{
			width: 800px; /* 40 round 20px*/
			height: 800px; /* 40 round  20px*/
			position: relative;
		}
		@media (max-width: 1280px), (max-height: 857px) {
			#game-screen{
				width: 720px; /* 40 round 18px*/
				height: 720px; /* 40 round 18px*/
			}
		}
		@media (max-width: 1080px), (max-height: 742px) {
			#game-screen{
				width: 640px; /* 40 round 16px*/
				height: 640px; /* 40 round 16px*/
			}
		}
		@media (max-width: 800px), (max-height: 769px) {
			#game-screen{
				width: 560px; /* 40 round 14px*/
				height: 560px; /* 40 round 14px*/
			}
		}
		@media (max-width: 700px), (max-height: 574px) {
			#game-screen{
				width: 400px; /* 40 round 14px*/
				height: 400px; /* 40 round 14px*/
			}
			#game-button-start, #game-button-pause{
				height: 1rem;
				width: 3rem;
				font-size: .5rem;
			}
			#game-score-time, #game-score-score, #game-score-highscore{
				width: 70px;
				font-size: 1rem;
			}
			#game-score-board{
				font-size: .8rem;
			}
		}
		@media (max-height: 414px) and (orientation: landscape) {
			#game-screen{
				width: unset;
				aspect-ratio: 1 / 1; /* 40 round 14px*/
				height: 90vh; /* 40 round 14px*/
			}
			#game-button-start, #game-button-pause{
				height: 1rem;
				width: 3rem;
				font-size: .5rem;
			}
			#game-score-time, #game-score-score, #game-score-highscore{
				width: 60px;
				font-size: .8rem;
			}
			#game-score-board{
				font-size: .6rem;
			}
		}
		@media (max-width: 500px) and (orientation: portrait) {
			#game-screen{
				height: unset;
				aspect-ratio: 1 / 1; /* 40 round 14px*/
				width: 90vw; /* 40 round 14px*/
			}
			#game-button-start, #game-button-pause{
				height: 1rem;
				width: 3rem;
				font-size: .5rem;
			}
			#game-score-time, #game-score-score, #game-score-highscore{
				width: 60px;
				font-size: .8rem;
			}
			#game-score-board{
				font-size: .6rem;
			}
		}
		

		

		/* BG Color */
		.myBG-1{ /*Gray*/
			background-color: rgba(106, 124, 135 , 1);
		}
		.myBG-2{
			background-color: rgb(248, 252, 255);
		}
		.myBG-4{ /*Dark*/
			background-color: rgba(50, 50, 50 , 1);
		}
		.myBG-5{ /*Darker*/
			background-color: rgb(27, 27, 36);
		}
		.myBG-6{ /*Blue*/
			background-color: rgb(94, 94, 119);
		}

		/* My Opacity */
		.myOpa-0{
			opacity: 0;
		}


		/* Width and Height */
		.myW-100{
			width: 100%;
		}
		.myH-100{
			height: 100%;
		}


		/* Positions */
		.myPos-absolute{
			position: absolute;
		}

		
		/* Overflow hidden */
		.myOverflow-Hidden{
			overflow: hidden;
		}
		

		/* Border Radius */
		.myBorderRadius-1r{
			border-radius: 1rem;
		}
		.myBorderRadius-5p{
			border-radius: 5px;
		}
		.myBorderRadius-10p{
			border-radius: 10px;
		}
		.myBorderRadius-TRBR-1r{
			border-radius: 0 1rem 1rem 0;
		}
		.myBorderRadius-TRBR-10p{
			border-radius: 0 10px 10px 0;
		}


		/* Border Outline */
		.myBorderOutline-All-1-1p{
			outline: rgb(94, 94, 119) solid 1px;
		}


		/* Flex */
		.myFlex, .myFA-center, .myFJ-center, .myFJ-between, .myFD-row, .myFD-row-NW, .myFD-col, .myFD-col-NW{
			display: flex;
			align-items: flex-start;
		}
		.myFA-center{
			align-items: center;
		}
		.myFJ-center{
			justify-content: center;
		}
		.myFJ-between{
			justify-content: space-between;
		}
		.myFD-row{
			flex-direction: row;
			flex-wrap: wrap;
		}
		.myFD-row-NW{
			flex-direction: row;
			flex-wrap: nowrap;
		}
		.myFD-col{
			flex-direction: column;
			flex-wrap: wrap;
		}
		.myFD-col-NW{
			flex-direction: column;
			flex-wrap: nowrap;
		}
		

		/* Margin and Padding */
		.myM-0{
			margin: 0;
		}
		.myMx-1{
			margin-left: 5px;
			margin-right: 5px;
		}
		.myP-0{
			padding: 0;
		}
		.myP-1{
			padding: 5px;
		}
		.myP-2, .myP-sm-2{
			padding: 10px;
		}
		@media (max-width: 500px) {
			.myP-sm-2{
				padding: 5px;
			}
		}
		.myPx-1{
			padding-left: 5px;
			padding-right: 5px;
		}
		.myPx-2{
			padding-left: 10px;
			padding-right: 10px;
		}
		.myPy-1{
			padding-top: 5px;
			padding-bottom: 5px;
		}
		.myPy-2{
			padding-top: 10px;
			padding-bottom: 10px;
		}

		/* Font Color*/
		.myFC-2{
			color: rgb(248, 252, 255);
		}
		.myFC-3{
			color: rgba(202, 255, 238, 1);
		}


		/* Font Family*/
		.myFont-Coda{
			font-family: 'Coda', cursive;
		}
		.myFont-Inconsolata{
			font-family: 'Inconsolata', monospace;
		}


		/* Font Size*/
		.myFontSize-0_8{
			font-size: 0.8rem;
		}
		.myFontSize-1{
			font-size: 1rem;
		}
		.myFontSize-1_2{
			font-size: 1.2rem;
		}
		.myFonxSize-1-0{
			font-size: 1rem;
		}


		/* Text Weight */
		.myFontWeight-lighter{
			font-weight: lighter;
		}


		/* Text Alignment*/
		.myTextAlign-center{
			text-align: center;
		}
		.myTextAlign-end{
			text-align: right;
		}


		/* Text Orientation */
		.myTextDirect-vertical{
			writing-mode: vertical-rl;
		}
		.myTextOrient-upright{
			text-orientation: upright;
		}

		
		/* Cursor*/
		.myCursor-pointer{
			cursor: pointer;
		}
		
	</style>
</head>
<body>
	<section id="game" class="mW-100 myFJ-center myFont-Coda ">
		<div id="game-container" class="myOverflow-Hidden myBorderRadius-5p myBorderOutline-All-1-1p">
			<!-- Screen of the game-->
			<div id="game-screen" class="myBG-4">
				<div id="game-screen-map" class="myPos-absolute myBG01 myW-100 myH-100" >
				</div>
				<div id="game-screen-click" class="myPos-absolute myBG01 myW-100 myH-100">s
				</div>
			</div>
			<!-- The Main Controls of the game-->
			<div id="game-control" class="myBG-5">
				<!-- pause and play-->
				<div class="myBG-1 myFD-col-NW myP-sm-2 myBorderRadius-10p myFA-center myFJ-center">
					<button id="game-button-start" type="button" class="myBG-4 myFC-2 myBorderRadius-5p myCursor-pointer" onclick="snakeGame.gameStart()" >START</button>
					<button id="game-button-pause" type="button" class="myBG-4 myFC-2 myBorderRadius-5p myCursor-pointer" onclick="snakeGame.gamePause()" disabled>PAUSE</button>
				</div>
				<!-- Score-->
				<div id="game-score-board" class="myBG-1 myFD-col-NW myP-1 myBorderRadius-10p myFC-2">
					<!-- Time -->
					<div class="myW-100 myPx-1 myFD-col-NW myFA-center">
						<div class="myTextAlign-center myW-100"> TIME </div>
						<div id="game-score-time" class="myBG-4 myTextAlign-end myFont-Inconsolata">
							0000000
						</div>
					</div>
					<!-- Current Score-->
					<div class="myW-100 myPx-1 myFD-col-NW myFA-center">
						<div class="myTextAlign-center myW-100"> SCORE </div>
						<div id="game-score-score" class="myBG-4 myTextAlign-end myFont-Inconsolata">
							0000000
						</div>
					</div>
					<!-- High Score-->
					<div class="myW-100 myPx-1 myFD-col-NW myFA-center">
						<div class="myTextAlign-center myW-100"> HIGHSCORE </div>
						<div id="game-score-highscore" class="myBG-4 myTextAlign-end myFont-Inconsolata">
							0000000
						</div>
					</div>
				</div>
			</div>
		</div>
	</section>

	<!-- Side Button-->
	<aside id="sideButton" class="myFD-row-NW myFA-center myFont-Coda myFC-2">
		<!-- Main Menu-->
		<div id="sideButton-menu" class="myBG-1 myBorderRadius-TRBR-1r" style="padding: 10px 0 5px 0;">
			<ul class= myFontWeight-lighter" style="list-style-type: none; padding-left: 10px; padding-top: 10px;">
				<li>W - Up</li>
				<li>S - Down</li>
				<li>A - Left</li>
				<li>D - Right</li>
				<li>Space(Hold) - 2x Speed</li>
				<li>____</li>
				<li>On mobile devices, Swipe the screen</li>
				<li>____</li>
			</ul>
			<h2 class="myTextAlign-center myFontSize-1 myFC-3 myFontWeight-lighter" style="padding-top: 10px;">CHOOSE DIFFICULTY</h2>
			<div class="" style="padding: 0 5px 10px 5px">
				<input id="difficulty-slider" class="myW-100 myM-0" type="range" min="1" max="10" value="5" onchange="promptNewDifficulty()" oninput="promptNewDifficulty()">
				<div id="difficulty-range" style="padding: 0 3px 0 3px" class="myW-100 myFJ-between">
					<y style="transform: translate(50%, 0%);">1</y>
					<y style="transform: translate(50%, 0%);">2</y>
					<y style="transform: translate(50%, 0%);">3</y>
					<y style="transform: translate(50%, 0%);">4</y>
					<y style="transform: translate(50%, 0%);">5</y>
					<y style="transform: translate(50%, 0%);">6</y>
					<y style="transform: translate(50%, 0%);">7</y>
					<y style="transform: translate(50%, 0%);">8</y>
					<y style="transform: translate(50%, 0%);">9</y>
					<y style="transform: translate(0%, 0%);">10</y>
				</div>
				<div id="difficulty-message" class="myFontSize-0_8" style="display: none">*click 'restart' to restart the game with choosen difficulty.</div>
			</div>
		</div>
		<!-- Main Menu Collapser-->
		<div id="menu-button" class="myBG-1 myTextDirect-vertical myCursor-pointer myPy-1 myBorderRadius-TRBR-10p myFC-3 myTextOrient-upright" onclick="openCloseMenu()"> CONTROLS </div>
	</aside>

	<script type="text/javascript">
		let $D = (x) => document.querySelector(x);
		class Screen{
			constructor(screenPixelID, screenClickID, pixel = [40, 40], size = [800, 800], framerate = 30){ //width height //x y //pixel size minus 1
				this.screenPixelID = screenPixelID;
				this.screenClickID = screenClickID
				this.pixel = pixel;
				this.size = size;
				this.cacheMap = {};
				this.pixelMap = {};
				this.pixelMapMemory = [{}];
				this.clickMap = {};
				this.clickMapMemory = {};
				this.preciseSize = [(size[0]/pixel[0]), (size[1]/pixel[1])];
				this.availableSpace = pixel[0]*pixel[1];
				this.occupiedSpace = 0;
				this.framerate = 30;
				this.$ID = $D('#'+this.screenPixelID);
				this.$CID = $D('#'+this.screenClickID);
				this.runScreen = setInterval(()=>{
					this.updateScreen();
				}, Math.floor(1000/framerate) )
				this.windowResizer = window.addEventListener('resize', ()=>{
					this.changeSize([this.$ID.clientWidth, this.$ID.clientHeight]);
				})
			}

			/*||| Preferably use within the class only |||*/
			helper_setAttribute(node, attributes){
				for(const i in attributes){
					node.setAttribute(''+i, attributes[i]);
				}
				return node;
			}
			helper_deleteMap(x, y){
				delete this.pixelMap[x][y];
				if( (Object.getOwnPropertyNames(this.pixelMap[x])).length <= 0 ){
					delete this.pixelMap[x];
				}	
			}
			/*||| Preferably use within the class only |||*/

			/////// The size of the screen
			changeSize(size){ // This will update the whole screen
				this.size = size;
				this.preciseSize = [(size[0]/this.pixel[0]), (size[1]/this.pixel[1])];
				this.updateScreen();
			}
			/////// The the pixel Sizzing
			changePixel(pixel){// This will reset the current screen and pixel mapping
				this.pixel = pixel;
				this.pixelMap = {};
				this.pixelMapMemory = [{}];
				this.clickMap = {};
				this.clickMapMemory = {}
				this.preciseSize = [(this.size[0]/pixel[0]), (this.size[1]/pixel[1])];
				this.updateScreen();
			}
			
			/////// Check if a certain pixel exist
			checkPixelMap(id='', location=''){
				if(id){
					if(location){
						if( this.pixelMap.hasOwnProperty( [location[0]] ) && this.pixelMap[location[0]].hasOwnProperty( location[1] ) && this.pixelMap[location[0]][location[1]].id == id){
							return [location[0], location[1]];
						}
					}
					else{
						for(const i in this.pixelMap){
							for(const j in this.pixelMap[i]){
								let contents = this.pixelMap[i][j];
								if(contents.id == id){
									return [i, j];
									break;
								}
							}
						}
					}
				}
				else if(location){
					if( this.pixelMap.hasOwnProperty( [location[0]] ) && this.pixelMap[location[0]].hasOwnProperty( location[1] ) ){
						return [location[0], location[1]];
					}
				}
				return false;
			}

			/////// List down all map that have pixel in array form
			getOccupiedSpaceList(){
				//let tempRawList = Object.getOwnPropertyNames(this.pixelMap);
				let listProperty = {};
				let index = 0;
				for(const i in this.pixelMap){
					for(const j in this.pixelMap[i]){
						listProperty[index++] = [i, j];
					}
				}
				return listProperty;
			}

			/////// List down all map that do not have a pixel yet in array form
			getAvailableSpaceList(){
				let listProperty = {};
				let index = 0;
				for(let i = 0; i < this.pixel[0]; i++){
					for(let j = 0; j < this.pixel[1]; j++){
						if( this.pixelMap.hasOwnProperty( i ) && this.pixelMap[ i ].hasOwnProperty( j ) ){
							continue;
						}
						else{
							listProperty[index++] = [i, j];
						}
					}
				}
				return listProperty;
			}

			/////// This will add one pixel in the screen// also maps in the screen mapper and update if there is already one pixel in the certain area
			addPixel(idName='', location = [0,0], color = 'rgb(248, 252, 255)'){
				// Add to internal Mapping
				if(this.pixelMap.hasOwnProperty( location[0] ) && this.pixelMap[location[0]].hasOwnProperty( location[1] )){
					this.removePixel('', location);
				}
				if(this.pixelMap.hasOwnProperty( location[0] )){
					this.pixelMap[location[0]][location[1]] = {'id':idName?idName:location[0]+'_'+location[1], 'class':'myPos-absolute myBG-2 '+('l-'+location[0]+'_'+location[1]), 'color':color};

				}else{
					this.pixelMap[location[0]] = {[location[1]]: {'id':idName?idName:location[0]+'_'+location[1], 'class':'myPos-absolute myBG-2 '+('l-'+location[0]+'_'+location[1]), 'color':color}};
				}

				//Update Space
				--this.availableSpace;
				++this.occupiedSpace;
			}
			
			/////// Remove the Pixel that are map in the mapping using either name or location
			removePixel(idName='', location = [0,0]){
				if(idName){
					for(const i in this.pixelMap){
						for(const j in this.pixelMap[i]){
							if(this.pixelMap[i][j].id == idName){
								this.helper_deleteMap(i, j);
								--this.occupiedSpace;
								++this.availableSpace;
								break;
							}
						}
					}
				}else{
					if( this.pixelMap.hasOwnProperty( location[0] ) && this.pixelMap[ location[0] ].hasOwnProperty( location[1] ) ){
						--this.occupiedSpace;
						++this.availableSpace;
						this.helper_deleteMap(location[0], location[1]);
					}
				}
			}

			/////// Dynamically draw a pixel in linear manner
			drawPixel(from = [0,0], to = [0,0], reverseDraw = false, color = 'rgb(248, 252, 255)'){
				let lengthX = to[0] - from[0] //Final minus Initial of X //100 - 0 = 100 || 0 - 100 = -100
				let lengthY = to[1] - from[1] //Final minus Initial of Y
				let directionX = lengthX>0?'RIGHT':'LEFT';
				let directionY = lengthY>0?'DOWN':'UP';
				lengthX = Math.abs(lengthX);
				lengthY = Math.abs(lengthY);
				if(lengthX >= lengthY){
					let ratio = lengthX / lengthY;
					for(let i = 0; i <= lengthX; i++){
						let xForward = directionX=='RIGHT'?from[0]+i:from[0]-i;
						let yForward = directionY=='DOWN'?from[1]+Math.floor(i/ratio):from[1]-Math.floor(i/ratio);
						if(!reverseDraw){
							this.addPixel('', [xForward, yForward], color);
						}
						else{
							this.removePixel('', [xForward, yForward]);
						}
						
					}
				}else{
					let ratio = lengthY / lengthX;
					for(let i = 0; i <= lengthY; i++){
						let xForward = directionX=='RIGHT'?from[0]+Math.floor(i/ratio):from[0]-Math.floor(i/ratio);
						let yForward = directionY=='DOWN'?from[1]+i:from[1]-i;
						if(!reverseDraw){
							this.addPixel('', [xForward, yForward], color);
						}
						else{
							this.removePixel('', [xForward, yForward]);
						}
						
					}
				}
			}

			/////// Flood a Pixel from one point to another
			floodPixel(from = [0,0], to = [0,0], reverseFlood=false, color = 'rgb(248, 252, 255)'){
				let lengthX = to[0] - from[0] //Final minus Initial of X //100 - 0 = 100 || 0 - 100 = -100
				let lengthY = to[1] - from[1] //Final minus Initial of Y
				let directionX = lengthX>0?'RIGHT':'LEFT';
				let directionY = lengthY>0?'DOWN':'UP';
				lengthX = Math.abs(lengthX);
				lengthY = Math.abs(lengthY);

				for(let i = 0; i <= lengthX; i++){
					let xForward = directionX=='RIGHT'?from[0]+i:from[0]-i;
					for(let j = 0; j <= lengthY; j++){
						let yForward = directionY=='DOWN'?from[1]+j:from[1]-j;
						if(!reverseFlood){
							this.addPixel('', [xForward, yForward], color);
						}
						else{
							this.removePixel('', [xForward, yForward]);
						}
					}
				}
			}

			clearAllPixel(){
				this.floodPixel([0,39], [39, 0], true);
			}

			savePixelMap(location = 0){
				this.pixelMapMemory[location] = structuredClone(this.pixelMap);
			}
			
			loadPixelMap(location = 0){
				this.pixelMap = structuredClone(this.pixelMapMemory[location]);
			}

			addToScreen(idName='', location = [0,0], color = 'rgb(248, 252, 255)'){
				//Create Pixel Attributes
				let newNode = document.createElement('div');
				let height = 'height: '+this.preciseSize[0]+'px; ';
				let width = 'width: '+this.preciseSize[1]+'px; ';
				let x = 'left: '+(this.preciseSize[0]*location[0])+'px; ';
				let y = 'top: '+(this.preciseSize[1]*location[1])+'px; ';
				let cssColor = 'background-color: '+color+'; ';

				//Insert it to the DOM screen				
				newNode = this.helper_setAttribute(newNode, {'id':idName?idName:location[0]+'_'+location[1], 'class':'myPos-absolute myBG-2 '+('l-'+location[0]+'_'+location[1]), 'style':height+width+x+y+cssColor});
				this.$ID.appendChild(newNode);
			}
			
			removeToScreen(idName='', location = [0,0]){
				if(idName){
					for(const i in this.pixelMap){
						for(const j in this.pixelMap[i]){
							if(this.pixelMap[i][j].id == idName){
								this.$ID.removeChild($D('#'+idName));
								break;
							}
						}
					}
				}else{
					if( this.pixelMap.hasOwnProperty( location[0] ) && this.pixelMap[ location[0] ].hasOwnProperty( location[1] ) ){
						try{
							this.$ID.removeChild( $D('.'+('l-'+location[0]+'_'+location[1])) );
						}
						catch{
							
						}
					}
				}
			}

			updateScreen(){
				this.clearScreen();
				for(const i in this.pixelMap){
					for(const j in this.pixelMap[i]){
						let contents = this.pixelMap[i][j];
						this.addToScreen(contents.id, [i, j], contents.color);
					}
				}
			}
			
			clearScreen(){
				this.$ID.textContent = '';
			}
			
			/*|||  CLICK MAP HERE |||*/
			addClickZone(idName='', handler = 'onclick', bind = 'alert(\'HERE!\')', cursor='pointer', from = [0,0], to = [1,1]){
				// Add to internal Mapping
				if(!this.clickMap.hasOwnProperty( idName )){
					cursor = 'cursor: '+cursor+'; ';
					this.clickMap[idName] = {'id':idName?idName:'cz-'+from[0]+'_'+from[1], 'style':cursor, 'handler':handler, 'bind':bind, 'location':[from, to]};
					
				}
			}
			removeClickZone(idName=''){
				if(this.clickMap.hasOwnProperty( idName )){
					delete this.clickMap[idName];
				}
			}

			addClickScreen(idName='',  handler= '', bind='', additionalStyle='', from=[0,0], to=[1,1]){
				//Plot location
				let lengthX = to[0] - from[0] //Final minus Initial of X //100 - 0 = 100 || 0 - 100 = -100
				let lengthY = to[1] - from[1] //Final minus Initial of Y
				let directionX = lengthX>0?'RIGHT':'LEFT';
				let directionY = lengthY>0?'DOWN':'UP';
				lengthX = Math.abs(lengthX);
				lengthY = Math.abs(lengthY);

				//Create Pixel Attributes
				let newNode = document.createElement('div');
				let height = 'height: '+(this.preciseSize[0] * lengthX)+'px; ';
				let width = 'width: '+(this.preciseSize[1] * lengthY)+'px; ';
				let x = 'left: '+(directionX=='RIGHT'?this.preciseSize[0]*from[0]:this.preciseSize[0]*to[0])+'px; ';
				let y = 'top: '+(directionY=='DOWN'?this.preciseSize[0]*from[1]:this.preciseSize[0]*to[1])+'px; ';

				//Insert it to the DOM screen				
				newNode = this.helper_setAttribute(newNode, {'id':idName, 'class':'myOpa-0 '+('cz-'+from[0]+'_'+from[1]), 'style':height+width+x+y+additionalStyle, [handler]:bind});
				this.$CID.prepend(newNode);
			}

			removeClickScreen(idName= ''){
				for(const i in this.clickMap){
					if(this.clickMap[i]['id'] == idName){
						this.$CID.removeChild($D('#'+idName));
						break;
					}
				}
			}

			updateClickScreen(){
				for(const i in this.clickMap){
					this.addClickScreen(this.clickMap[i]['id'], this.clickMap[i]['handler'], this.clickMap[i]['bind'], this.clickMap[i]['style'], this.clickMap[i]['location'][0], this.clickMap[i]['location'][1]);
				}
			}

			clearClickScreen(){
				this.$CID.textContent = '';
			}

			saveClickMap(location = 0){
				this.clickMapMemory[location] = structuredClone(this.clickMap);
			}
			
			loadClickMap(location = 0){
				this.clickMap = structuredClone(this.clickMapMemory[location]);
			}
		}
	let snakeScreen = new Screen('game-screen-map', 'game-screen-click');
	snakeScreen.changeSize([$D('#game-screen').clientWidth, $D('#game-screen').clientHeight]);
	/*
	snakeScreen.addPixel('snake', [4,1]);
	snakeScreen.addPixel('', [39,39]);
	snakeScreen.addPixel('', [29,34]);
	//console.log(snakeScreen.pixelMap);
	//console.log(snakeScreen.getOccupiedSpaceList());
	//console.log(snakeScreen.getAvailableSpaceList());
	snakeScreen.removePixel('', [4, 1])
	//console.log(snakeScreen.pixelMap);
	snakeScreen.drawPixel([0,39], [39,0]);
	console.log(snakeScreen.getOccupiedSpaceList());
	snakeScreen.floodPixel([0,20], [39,20], false, 'rgb(250, 250, 0)');
	//snakeScreen.drawPixel([0,39], [39,0], true);
	snakeScreen.updateScreen();
	snakeScreen.addClickZone('HELLOWORLD', 'onclick', 'alert(\'HERE!\')', 'pointer', [0,0], [10,10]);
	snakeScreen.updateClickScreen();
	snakeScreen.updateClickScreen();
	console.log(snakeScreen.getOccupiedSpaceList());
	let exampletime = 0;
	*/
	
	// S
	snakeScreen.drawPixel([6, 21], [9, 21], false, 'rgb(35, 195, 231)');
	snakeScreen.drawPixel([6, 22], [6, 23], false, 'rgb(35, 195, 231)');
	snakeScreen.drawPixel([7, 23], [8, 23], false, 'rgb(35, 195, 231)');
	snakeScreen.drawPixel([9, 24], [9, 26], false, 'rgb(35, 195, 231)');
	snakeScreen.drawPixel([8, 26], [6, 26], false, 'rgb(35, 195, 231)');
	snakeScreen.addPixel('', [6, 25], 'rgb(35, 195, 231)');
	// T
	snakeScreen.drawPixel([11, 21], [15, 21], false, 'rgb(35, 195, 231)');
	snakeScreen.drawPixel([13, 22], [13, 26], false, 'rgb(35, 195, 231)');
	// A
	snakeScreen.addPixel('', [19, 21], 'rgb(35, 195, 231)');
	snakeScreen.drawPixel([18, 22], [18, 23], false, 'rgb(35, 195, 231)');
	snakeScreen.drawPixel([20, 22], [20, 23], false, 'rgb(35, 195, 231)');
	snakeScreen.drawPixel([17, 24], [21, 24], false, 'rgb(35, 195, 231)');
	snakeScreen.drawPixel([17, 25], [17, 26], false, 'rgb(35, 195, 231)');
	snakeScreen.drawPixel([21, 25], [21, 26], false, 'rgb(35, 195, 231)');
	// R
	snakeScreen.drawPixel([24, 21], [24, 26], false, 'rgb(35, 195, 231)');
	snakeScreen.drawPixel([25, 21], [26, 21], false, 'rgb(35, 195, 231)');
	snakeScreen.drawPixel([27, 22], [27, 23], false, 'rgb(35, 195, 231)');
	snakeScreen.drawPixel([26, 24], [25, 24], false, 'rgb(35, 195, 231)');
	snakeScreen.drawPixel([27, 25], [27, 26], false, 'rgb(35, 195, 231)');
	// T
	snakeScreen.drawPixel([29, 21], [33, 21], false, 'rgb(35, 195, 231)');
	snakeScreen.drawPixel([31, 22], [31, 26], false, 'rgb(35, 195, 231)');

	// P
	snakeScreen.drawPixel([6, 12], [6, 17], false, 'rgb(70, 94, 157)');
	snakeScreen.drawPixel([7, 12], [8, 12], false, 'rgb(70, 94, 157)');
	snakeScreen.drawPixel([9, 13], [9, 14], false, 'rgb(70, 94, 157)');
	snakeScreen.drawPixel([7, 15], [8, 15], false, 'rgb(70, 94, 157)');
	// R
	snakeScreen.drawPixel([12, 12], [12, 17], false, 'rgb(70, 94, 157)');
	snakeScreen.drawPixel([13, 12], [14, 12], false, 'rgb(70, 94, 157)');
	snakeScreen.drawPixel([15, 13], [15, 14], false, 'rgb(70, 94, 157)');
	snakeScreen.drawPixel([13, 15], [14, 15], false, 'rgb(70, 94, 157)');
	snakeScreen.drawPixel([15, 16], [15, 17], false, 'rgb(70, 94, 157)');
	// E
	snakeScreen.drawPixel([18, 12], [18, 17], false, 'rgb(70, 94, 157)');
	snakeScreen.drawPixel([18, 12], [21, 12], false, 'rgb(70, 94, 157)');
	snakeScreen.drawPixel([18, 14], [20, 14], false, 'rgb(70, 94, 157)');
	snakeScreen.drawPixel([13, 15], [14, 15], false, 'rgb(70, 94, 157)');
	snakeScreen.drawPixel([19, 17], [21, 17], false, 'rgb(70, 94, 157)');
	// S
	snakeScreen.drawPixel([24, 12], [27, 12], false, 'rgb(70, 94, 157)');
	snakeScreen.drawPixel([24, 13], [24, 14], false, 'rgb(70, 94, 157)');
	snakeScreen.drawPixel([25, 14], [26, 14], false, 'rgb(70, 94, 157)');
	snakeScreen.drawPixel([27, 15], [27, 17], false, 'rgb(70, 94, 157)');
	snakeScreen.drawPixel([26, 17], [24, 17], false, 'rgb(70, 94, 157)');
	snakeScreen.addPixel('', [24, 16], 'rgb(70, 94, 157)');
	// S
	snakeScreen.drawPixel([30, 12], [33, 12], false, 'rgb(70, 94, 157)');
	snakeScreen.drawPixel([30, 13], [30, 14], false, 'rgb(70, 94, 157)');
	snakeScreen.drawPixel([31, 14], [32, 14], false, 'rgb(70, 94, 157)');
	snakeScreen.drawPixel([33, 15], [33, 17], false, 'rgb(70, 94, 157)');
	snakeScreen.drawPixel([33, 17], [30, 17], false, 'rgb(70, 94, 157)');
	snakeScreen.addPixel('', [30, 16], 'rgb(70, 94, 157)');

	snakeScreen.savePixelMap(1);
	snakeScreen.clearAllPixel();

	snakeScreen.addClickZone('game-start', 'onclick', 'snakeGame.gameStart()', 'pointer', [0,0], [39,39]);
	snakeScreen.saveClickMap(1);
	snakeScreen.removeClickZone('game-start');

	//P
	snakeScreen.drawPixel([3, 17], [3, 22], false, 'rgb(70, 94, 157)');
	snakeScreen.drawPixel([4, 17], [5, 17], false, 'rgb(70, 94, 157)');
	snakeScreen.drawPixel([6, 18], [6, 19], false, 'rgb(70, 94, 157)');
	snakeScreen.drawPixel([5, 20], [4, 20], false, 'rgb(70, 94, 157)');
	//A
	snakeScreen.addPixel('', [10, 17], 'rgb(70, 94, 157)');
	snakeScreen.drawPixel([9, 18], [9, 19], false, 'rgb(70, 94, 157)');
	snakeScreen.drawPixel([11, 18], [11, 19], false, 'rgb(70, 94, 157)');
	snakeScreen.drawPixel([8, 20], [12, 20], false, 'rgb(70, 94, 157)');
	snakeScreen.drawPixel([8, 21], [8, 22], false, 'rgb(70, 94, 157)');
	snakeScreen.drawPixel([12, 21], [12, 22], false, 'rgb(70, 94, 157)');
	//U
	snakeScreen.drawPixel([15, 17], [15, 21], false, 'rgb(70, 94, 157)');
	snakeScreen.drawPixel([16, 22], [18, 22], false, 'rgb(70, 94, 157)');
	snakeScreen.drawPixel([19, 17], [19, 21], false, 'rgb(70, 94, 157)');
	//S
	snakeScreen.drawPixel([23, 17], [25, 17], false, 'rgb(70, 94, 157)');
	snakeScreen.drawPixel([22, 18], [22, 19], false, 'rgb(70, 94, 157)');
	snakeScreen.drawPixel([23, 20], [24, 20], false, 'rgb(70, 94, 157)');
	snakeScreen.addPixel('', [25, 21], 'rgb(70, 94, 157)');
	snakeScreen.drawPixel([22, 22], [24, 22], false, 'rgb(70, 94, 157)');
	//E
	snakeScreen.drawPixel([27, 17], [27, 22], false, 'rgb(70, 94, 157)');
	snakeScreen.drawPixel([28, 17], [30, 17], false, 'rgb(70, 94, 157)');
	snakeScreen.drawPixel([28, 20], [29, 20], false, 'rgb(70, 94, 157)');
	snakeScreen.drawPixel([28, 22], [30, 22], false, 'rgb(70, 94, 157)');
	//D
	snakeScreen.drawPixel([32, 17], [32, 22], false, 'rgb(70, 94, 157)');
	snakeScreen.drawPixel([33, 17], [35, 17], false, 'rgb(70, 94, 157)');
	snakeScreen.drawPixel([36, 18], [36, 21], false, 'rgb(70, 94, 157)');
	snakeScreen.drawPixel([33, 22], [35, 22], false, 'rgb(70, 94, 157)');

	snakeScreen.savePixelMap(2);
	snakeScreen.clearAllPixel();

	snakeScreen.addClickZone('game-pause', 'onclick', 'snakeGame.gameUnPause()', 'pointer', [0,0], [39,39]);
	snakeScreen.saveClickMap(2);
	snakeScreen.removeClickZone('game-pause');

	//G
	snakeScreen.drawPixel([6, 13], [10, 13], false, 'rgb(254, 183, 177)');
	snakeScreen.drawPixel([5, 14], [5, 17], false, 'rgb(254, 183, 177)');
	snakeScreen.drawPixel([6, 18], [10, 18], false, 'rgb(254, 183, 177)');
	snakeScreen.drawPixel([11, 17], [11, 16], false, 'rgb(254, 183, 177)');
	snakeScreen.drawPixel([10, 16], [9, 16], false, 'rgb(254, 183, 177)');
	snakeScreen.addPixel('', [6, 14], 'rgb(254, 183, 177)');
	snakeScreen.addPixel('', [6, 17 ], 'rgb(254, 183, 177)');
	//A
	snakeScreen.drawPixel([14, 13], [16, 13], false, 'rgb(254, 183, 177)');
	snakeScreen.drawPixel([14, 14], [16, 14], false, 'rgb(254, 183, 177)');
	snakeScreen.drawPixel([13, 15], [13, 18], false, 'rgb(254, 183, 177)');
	snakeScreen.drawPixel([14, 15], [14, 17], false, 'rgb(254, 183, 177)');
	snakeScreen.drawPixel([16, 15], [16, 17], false, 'rgb(254, 183, 177)');
	snakeScreen.drawPixel([17, 15], [17, 18], false, 'rgb(254, 183, 177)');
	snakeScreen.addPixel('', [15, 17], 'rgb(254, 183, 177)');
	//M
	snakeScreen.drawPixel([20, 14], [20, 18], false, 'rgb(254, 183, 177)');
	snakeScreen.drawPixel([21, 13], [21, 14], false, 'rgb(254, 183, 177)');
	snakeScreen.drawPixel([22, 13], [22, 15], false, 'rgb(254, 183, 177)');
	snakeScreen.drawPixel([23, 14], [23, 18], false, 'rgb(254, 183, 177)');
	snakeScreen.drawPixel([24, 15], [24, 18], false, 'rgb(254, 183, 177)');
	snakeScreen.drawPixel([25, 13], [25, 14], false, 'rgb(254, 183, 177)');
	snakeScreen.drawPixel([26, 13], [26, 15], false, 'rgb(254, 183, 177)');
	snakeScreen.drawPixel([27, 14], [27, 18], false, 'rgb(254, 183, 177)');
	//E
	snakeScreen.drawPixel([30, 13], [30, 18], false, 'rgb(254, 183, 177)');
	snakeScreen.drawPixel([31, 13], [33, 13], false, 'rgb(254, 183, 177)');
	snakeScreen.drawPixel([31, 15], [32, 15], false, 'rgb(254, 183, 177)');
	snakeScreen.drawPixel([31, 18], [33, 18], false, 'rgb(254, 183, 177)');
	//O
	snakeScreen.drawPixel([7, 22], [7, 25], false, 'rgb(255, 61, 45)');
	snakeScreen.drawPixel([8, 21], [8, 22], false, 'rgb(255, 61, 45)');
	snakeScreen.drawPixel([8, 25], [8, 26], false, 'rgb(255, 61, 45)');
	snakeScreen.drawPixel([9, 21], [11, 21], false, 'rgb(255, 61, 45)');
	snakeScreen.drawPixel([9, 26], [11, 26], false, 'rgb(255, 61, 45)');
	snakeScreen.drawPixel([12, 21], [12, 22], false, 'rgb(255, 61, 45)');
	snakeScreen.drawPixel([12, 25], [12, 26], false, 'rgb(255, 61, 45)');
	snakeScreen.drawPixel([13, 22], [13, 25], false, 'rgb(255, 61, 45)');
	//V
	snakeScreen.drawPixel([16, 21], [16, 24], false, 'rgb(255, 61, 45)');
	snakeScreen.drawPixel([17, 25], [17, 26], false, 'rgb(255, 61, 45)');
	snakeScreen.drawPixel([18, 25], [18, 26], false, 'rgb(255, 61, 45)');
	snakeScreen.drawPixel([19, 21], [19, 24], false, 'rgb(255, 61, 45)');
	//E
	snakeScreen.drawPixel([23, 21], [23, 26], false, 'rgb(255, 61, 45)');
	snakeScreen.drawPixel([24, 21], [26, 21], false, 'rgb(255, 61, 45)');
	snakeScreen.drawPixel([24, 23], [25, 23], false, 'rgb(255, 61, 45)');
	snakeScreen.drawPixel([24, 26], [26, 26], false, 'rgb(255, 61, 45)');
	//R
	snakeScreen.drawPixel([29, 21], [29, 26], false, 'rgb(255, 61, 45)');
	snakeScreen.drawPixel([30, 21], [31, 21], false, 'rgb(255, 61, 45)');
	snakeScreen.drawPixel([32, 22], [32, 23], false, 'rgb(255, 61, 45)');
	snakeScreen.drawPixel([30, 24], [31, 24], false, 'rgb(255, 61, 45)');
	snakeScreen.drawPixel([32, 25], [32, 26], false, 'rgb(255, 61, 45)');

	snakeScreen.savePixelMap(3);
	snakeScreen.clearAllPixel();

	////// KEY MAPPING
	class KeyBind{
		/*For touchKey
			- Swipe = 8, 4, Y, X, No Limit
			- Drag
			- Tap
			- UnTap
		*/
		constructor(useKey = ['ArrowUp', 'ArrowRight', 'ArrowDown', 'ArrowLeft', 'KeyW', 'KeyD', 'KeyS', 'KeyA', 'Space'], touchKey = {'Swipe':'4'}, gameLink = (activeKeys)=>{}){
			this.currentActive = '';
			this.keyStackOrder = [];
			this.useKey = useKey;
			this.touchKey = touchKey;
			this.gameLink = a => gameLink(a);
		}

		insertGameLink(callback){
			this.gameLink = callback;
		}

		helper_insertStack(keys){
			if( this.keyStackOrder.includes(keys) ){
				delete this.keyStackOrder[ this.keyStackOrder.indexOf(keys) ];
				this.keyStackOrder = this.keyStackOrder.filter(n => n != null);
			}
			this.keyStackOrder.push(keys);
			return this.keyStackOrder;
		}

		tapPress(event){
			for(const i in this.keyStackOrder){
				if(this.keyStackOrder[i] == event.code){
					return false;
				}
			}
			for(const i in this.useKey){
				if(this.useKey[i] == event.code){
					this.keyStackOrder.push(this.useKey[i]);
				}
			}
			this.gameLink(this.keyStackOrder);
		}

		outPress(event){
			for(const i in this.keyStackOrder){
				if(this.keyStackOrder[i] == event.code){
					delete this.keyStackOrder[i];
					this.keyStackOrder = this.keyStackOrder.filter(n => n != null);
					break;
				}
			}
			this.gameLink(this.keyStackOrder);
		}

		touchTap(event){
			let touchDescription =  event.changedTouches[0];
			this.touchStart = [touchDescription.screenX, touchDescription.screenY];
		}
		touchGone(event){
			let touchDescription =  event.changedTouches[0];
			this.touchEnd = [touchDescription.screenX, touchDescription.screenY];

			this.calculateTouch();
		}
		calculateTouch(){
			for(const i in this.touchKey){
				switch(i){
					case 'Swipe':
						let swipeX = this.touchEnd[0] - this.touchStart[0];
						let swipeY = this.touchEnd[1] - this.touchStart[1];
						let direction = '';
						if(this.touchKey[i] == '4'){
							if(Math.abs(swipeX) > Math.abs(swipeY)){
								if(swipeX > 10)
									direction = 'Right';
								else if(swipeX < -10)
									direction = 'Left';
							}else{
								if(swipeY > 10)
									direction = 'Down';
								else if(swipeY < -10)
									direction = 'Up';
							}
						}
						if(direction != ''){
							this.keyStackOrder.push(direction);
							this.gameLink(this.keyStackOrder);
							delete this.keyStackOrder[ this.keyStackOrder.indexOf(direction) ];
							this.keyStackOrder = this.keyStackOrder.filter(n => n != null);
						}
						break;
					case 'Drag':
						this.gameLink();
						break;
					case 'Tap':
						this.gameLink();
						break;
					case 'UnTap':
						this.gameLink();
						break;
					default:{

					}
						
				}
			}

			for(const i in this.keyStackOrder){
				if(this.keyStackOrder[i] == event.code){
					return false;
				}
			}
			for(const i in this.useKey){
				if(this.useKey[i] == event.code){
					this.keyStackOrder.push(this.useKey[i]);
					return true;
				}
			}
		}

		runBinding(){
			window.addEventListener('keydown', e=> this.tapPress(e));
			window.addEventListener('keyup', e=> this.outPress(e));
			window.addEventListener('touchstart', e => this.touchTap(e));
			window.addEventListener('touchend', e => this.touchGone(e));
		}


	}
	let snakeKeyBind = new KeyBind();
	snakeKeyBind.runBinding();

	////// SCORE BOARD
	class ScoreBoard{
		constructor(timerID, scoreID, highScoreID){
			this.timerID = '#'+timerID;
			this.scoreID = '#'+scoreID;
			this.hs_ID = '#'+highScoreID;
			this.currentScore =0;
			this.currentTime =0.0;
			this.currentHighScore =0;
			this.timeStarted = false;
			this.timePaused = false;
		}

		startTime(){
			if(this.timeStarted == false){
				this.currentTime = 0;
				$D(this.timerID).textContent = '';
				$D(this.timerID).textContent = '0000000';
				this.timeField = setInterval(()=>{
					this.currentTime = this.currentTime+ 0.1;
					this.updateTime();
				}, 100);
				this.timeStarted = true;
			}
		}
		
		pauseTime(){
			if(this.timeStarted == true && this.timePaused == false){
				clearInterval(this.timeField);
				this.timePaused = true;
			}
		}
		
		unpauseTime(){
			if(this.timeStarted == true && this.timePaused == true){
				this.timeField = setInterval(()=>{
					this.currentTime = this.currentTime+ 0.1;
					this.updateTime();
				}, 100);
				this.timePaused = false;
			}
		}

		stopTime(){
			if(this.timeStarted == true){
				clearInterval(this.timeField);
				this.currentTime = 0;
				this.timeStarted = false;
			}
		}

		updateTime(){
			let tempN = (this.currentTime + 10000000)+"";
			$D(this.timerID).textContent = '';
			$D(this.timerID).textContent = tempN.substring(1, 8);
		}
		
		getCurrentTime(){
			return Math.floor(this.currentTime);
		}

		//// Score Board
		addCurrentScore(points){
			this.currentScore = this.currentScore + points;
		}
		updateScore(){
			let tempN = (this.currentScore + 10000000)+"";
			$D(this.scoreID).textContent = '';
			$D(this.scoreID).textContent = tempN.substring(1);
		}
		resetScore(){
			this.currentScore = 0;
			$D(this.scoreID).textContent = '';
			$D(this.scoreID).textContent = '0000000';
		}

		//// HighScore
		comchangeHighScore(){
			if(this.currentScore > this.currentHighScore){
				this.currentHighScore = this.currentScore;
				this.updateHighScore();
			}
		}
		updateHighScore(){
			let tempN = (this.currentHighScore + 10000000)+"";
			$D(this.hs_ID).textContent = '';
			$D(this.hs_ID).textContent = tempN.substring(1);
		}
		clearHighScore(){
			this.currentHighScore = 0;
			$D(this.hs_ID).textContent = '';
			$D(this.hs_ID).textContent = '0000000';
		}
	}
	let scoreBoard = new ScoreBoard('game-score-time', 'game-score-score', 'game-score-highscore');

	////// SNAKE ENGINE
	class SnakeEngine{
		constructor(){
			this.difficulty = $D('#difficulty-slider').value;
			this.speed = Math.floor(1000/this.difficulty);
			this.start = false;
			this.currentMove = 'right';
			this.pastMove = 'right';
			this.speedOfSnake = 1;
			this.lengthOfSnake = 0;
			this.gameRunning = 0;
			this.isPause = 0;
		}

		helper_randInt(max) {
			let x = Math.floor(Math.random() * max);
			x = x==max?x-1:x;	
			return x;
		}

		gameMenu(){
			snakeScreen.loadPixelMap(1);
			snakeScreen.loadClickMap(1);
			snakeScreen.updateClickScreen();
		}
		clearGameMenu(){
			snakeScreen.clearAllPixel();
			snakeScreen.removeClickZone('game-start');
			snakeScreen.updateClickScreen();
			snakeScreen.clearClickScreen();
		}
		gameStart(){
			if(this.start == false){
				scoreBoard.startTime();
				scoreBoard.resetScore();
				this.eatInterval = 0;
				this.clearGameMenu();
				this.lengthOfSnake = 0;
				this.currentMove = 'right';
				this.pastMove = 'right';
				this.difficulty = $D('#difficulty-slider').value;
				this.speed = Math.floor(1000/this.difficulty);
				this.speedOfSnake = 1;
				this.makeSnake();
				this.makeFood();
				this.gameRunning = 1;
				this.gameRun();
				this.start = true;
				$D('#game-button-pause').removeAttribute('disabled');
				$D('#game-button-start').setAttribute('onclick', 'snakeGame.gameRestart()');
				$D('#game-button-start').textContent = 'RESTART';
				$D('#difficulty-message').setAttribute('style', 'display: none');
			}
		}
		gameRestart(){
			this.gameOver();
			this.gameStart();
		}
		gameRun(){
			this.animateSnake = setInterval(()=>{
				this.moveSnake();
			}, Math.floor(this.speed*(1/this.speedOfSnake)) );
		}
		gameKeys(keys){
			if(this.isPause != 1 && this.start != false){
				let latestActiveKey = keys[keys.length-1];
				let oldMove = this.currentMove;
				switch(latestActiveKey){
					case 'ArrowUp':
					case 'KeyW':
					case 'Up':
						this.currentMove = 'up';
					break;

					case 'ArrowRight':
					case 'KeyD':
					case 'Right':
						this.currentMove = 'right';
					break;

					case 'ArrowDown': 
					case 'KeyS':
					case 'Down': 
						this.currentMove = 'down';
					break;

					case 'ArrowLeft': 
					case 'KeyA': 
					case 'Left': 
						this.currentMove = 'left';
					break;
				}

				if( (this.currentMove == 'left' || this.currentMove == 'right') && (oldMove == 'left' || oldMove == 'right')){
					this.currentMove = oldMove;
				}
				else if( (this.currentMove == 'down' || this.currentMove == 'up' ) && (oldMove == 'down' || oldMove == 'up' )){
					this.currentMove = oldMove;
				}
				

				let speeding = false;
				for(const i in keys){
					if(keys[i] == 'Space'){
						speeding = true;
						break;
					}
				}
				if(this.speedOfSnake == 1 && speeding == true){
					this.speedOfSnake = 2;
					this.changeSpeed();
				}
				else if(this.speedOfSnake == 2 && speeding == false){
					
					this.speedOfSnake = 1;
					this.changeSpeed();
				}
			}
		}

		gamePause(){
			if(this.isPause == 0){
				clearInterval(this.animateSnake);
				snakeScreen.savePixelMap(0);
				snakeScreen.clearAllPixel();
				snakeScreen.loadPixelMap(2);
				snakeScreen.loadClickMap(2);
				snakeScreen.updateClickScreen();
				scoreBoard.pauseTime();
				this.isPause = 1;
				$D('#game-button-pause').textContent = 'PLAY';
				$D('#game-button-pause').setAttribute('onclick', 'snakeGame.gameUnPause()');
			}
		}
		gameUnPause(){
			if(this.isPause == 1){
				snakeScreen.clearAllPixel();
				snakeScreen.clearScreen();
				snakeScreen.removeClickZone('game-pause')
				snakeScreen.clearClickScreen();
				snakeScreen.loadPixelMap(0);
				this.gameRun();
				scoreBoard.unpauseTime();
				this.isPause = 0;
				$D('#game-button-pause').textContent = 'PAUSE';
				$D('#game-button-pause').setAttribute('onclick', 'snakeGame.gamePause()');
			}
		}

		gameOver(){
			if(this.start == true){
				this.start = false;
				clearInterval(this.animateSnake);
				snakeScreen.clearAllPixel();
				snakeScreen.loadPixelMap(3);
				snakeScreen.loadClickMap(1);
				snakeScreen.updateClickScreen();
				scoreBoard.stopTime();
				$D('#game-button-pause').setAttribute('disabled', true);
				$D('#game-button-start').textContent = 'START';
				return true;
			}	
		}

		changeSpeed(){
			clearInterval(this.animateSnake);
			this.animateSnake = setInterval(()=>{
				this.moveSnake();
			}, Math.floor(this.speed*(1/this.speedOfSnake)) );
		}

		insertRandomizeLocation(idName='', color='rgb(248, 252, 255)'){
			let occupiedSpace = snakeScreen.getAvailableSpaceList();
			snakeScreen.addPixel(idName, occupiedSpace[this.helper_randInt(Object.keys(occupiedSpace).length)], color);
		}

		moveSnake(){
			if(this.start == false || this.gamePause == 1)
				return false;

			let moveset = snakeScreen.checkPixelMap('snake-head');
			moveset = [parseInt(moveset[0]), parseInt(moveset[1])];
			let oldMove = [moveset[0], moveset[1]];
			let pixelHeight = snakeScreen.pixel[0];
			let pixelWidth = snakeScreen.pixel[1];
			switch(this.currentMove){
				case 'up':
					if(this.pastMove != 'down'){
						moveset[1] = moveset[1]-1<0?pixelHeight-1:moveset[1]-1;
						this.pastMove = this.currentMove;
					}else{
						moveset[1] = (moveset[1]+1)%pixelHeight;
					}
					break;
				case 'right':
					if(this.pastMove != 'left'){
						moveset[0] = (moveset[0]+1)%pixelWidth;
						this.pastMove = this.currentMove;
					}else{
						moveset[0] = moveset[0]-1<0?pixelWidth-1:moveset[0]-1;
					}
					break;
				case 'down':
					if(this.pastMove != 'up'){
						moveset[1] = (moveset[1]+1)%pixelHeight;
						this.pastMove = this.currentMove;
					}else{
						moveset[1] = moveset[1]-1<0?pixelHeight-1:moveset[1]-1;
					}
					break;
				case 'left':
					if(this.pastMove != 'right'){
						moveset[0] = moveset[0]-1<0?pixelWidth-1:moveset[0]-1;
						this.pastMove = this.currentMove;
					}else{
						moveset[0] = (moveset[0]+1)%pixelWidth;
					}
					break;
			}
			if( !this.eatTail(moveset) ){
				let checkMateFood = this.eatFood(moveset);
				snakeScreen.removePixel('snake-head');
				snakeScreen.addPixel('snake-head', moveset, 'rgb(100, 165, 244)');
				this.tailingSnake(oldMove, 1, checkMateFood);
			}
			else{
				this.gameOver();
			}
			
		}

		tailingSnake(moveset, length, eatFood){
			if(length > this.lengthOfSnake){
				if(eatFood == true){
					snakeScreen.addPixel('snake-tail-'+length, moveset, 'rgb(90, 150, 223)');
					this.lengthOfSnake = length;
				}
				return false;
			}else{
				let oldmove = snakeScreen.checkPixelMap('snake-tail-'+length);
				snakeScreen.removePixel('snake-tail-'+length);
				snakeScreen.addPixel('snake-tail-'+length, moveset, 'rgb(90, 150, 223)');
				this.tailingSnake(oldmove, length+1, eatFood);
			}
		}

		makeSnake(){
			this.insertRandomizeLocation('snake-head', 'rgb(100, 165, 244)');
		}
		makeFood(){
			this.insertRandomizeLocation('snake-food', 'rgb(255, 87, 51)');
		}

		eatFood(nextMove){
			let foodLocation = snakeScreen.checkPixelMap('snake-food');
			if(foodLocation[0] == nextMove[0] && foodLocation[1] == nextMove[1]){
				snakeScreen.removePixel('snake-food');
				this.makeFood();
				scoreBoard.addCurrentScore( (scoreBoard.getCurrentTime() - this.eatInterval) < (7+parseInt(this.difficulty))?(2*this.difficulty):(1*this.difficulty) );
				this.eatInterval = scoreBoard.getCurrentTime();
				scoreBoard.updateScore();
				scoreBoard.comchangeHighScore();
				return true;
			}
			return false;
		}

		eatTail(nextMove, index = this.lengthOfSnake){
			if(index > 0){
				let tail = snakeScreen.checkPixelMap('snake-tail-'+index);
				if(this.gameRunning == 0 || (tail[0] == nextMove[0] && tail[1] == nextMove[1])){
					return true;
					this.gameRunning = 0;
				}
				else{
					if( this.eatTail(nextMove, index-1) ){
						return true;
						this.gameRunning = 0;
					}
				}
			}
			return false;
		}
		
	}
	let snakeGame = new SnakeEngine();
	snakeGame.gameMenu();
	snakeKeyBind.insertGameLink((event)=>snakeGame.gameKeys(event));


$D('button').addEventListener('onMouseDown', 	function (e) {
	event.preventDefault();
	return false;
})
$D('button').addEventListener('keyup', 	function (e) {
	event.preventDefault();
    return false;
})


let isMenuOpen = false;
const gameMenuResize = ()=>{
	console.log(window.innerWidth);
	if(window.innerWidth < 1410){
		$D('#sideButton-menu').setAttribute('style', 'display: none');
		isMenuOpen = false;
	}else{
		$D('#sideButton-menu').setAttribute('style', 'display: block');
		isMenuOpen = true;
	}
}
gameMenuResize();
window.addEventListener('resize', gameMenuResize);

function openCloseMenu(){
	if(isMenuOpen){
		$D('#sideButton-menu').setAttribute('style', 'display: none');
		isMenuOpen = false;
	}else{
		$D('#sideButton-menu').setAttribute('style', 'display: block');
		isMenuOpen = true;
	}
}

function promptNewDifficulty(){
	$D('#difficulty-message').setAttribute('style', 'display: block');
}
	</script>
</body>
</html>